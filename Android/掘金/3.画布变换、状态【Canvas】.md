# 3.画布变换、状态【Canvas】

上节课我们学习了`Paint`相关知识，这节课我们看看自定义绘制中最重要的知识点，画布[Canvas]。毫不夸张的说，理解画布Canvas的相关知识，才可以游刃有余地解决很多绘制场景中的难题，才算得上我们也写过自定义绘制控件。

所以这节课必须自己动手实操，掌握以下知识点：

- 画布的变换
- 画布状态的储存与恢复
- 画布相关的绘制
- 其他相关的知识点-作为了解

## 画布变换

计算机图形学，机器人学，无人驾驶，深度学习，电子工程，通常都是将矩阵作为一种工具来使用。矩阵从出现以来在线性代数在各种学科都有其重要作用，甚至初代量子力学又称为矩阵力学，另一方面在现代科技的发展中有着极其重要的左右，尤其在芯片以大型计算器等领域可以提高计算速度，例如，GPU能够针对这个进行优化，如果不以矩阵的形式表示数据，GPU的优势也没法发挥到极致。很多时候我们可以通过矩阵运算将多维度的数据计算进行降纬，能够解决很多复杂飞线性的问题。

在Android的View层对绘图进行变换，都是建立在矩阵Matrix类`*android.graphics.Matrix*`的基础上，该类是一个矩阵工具类，提供了一些常用的画布变换方法，当然了如果理解了原理，你也可以通过手写Matrix写出更多的变换方案，结合Canvas来实现丰富多姿的图形变换表现。

Android中，Google在Matrix基础上提供的控制图片变换的常用方法，如下：

- setTranslate(float dx,float dy)：控制Matrix将画布水平垂直方向上进行变换。
- setRotate(float degrees)：控制Matrix将画布进行一定角度的旋转，轴心为（0,0)。
- setScale(float sx,float sy)：设置Matrix将画布进行缩放，sx、sy为X、Y方向上的缩放比例。
- setSkew(float kx,float ky)：控制Matrix将画布进行倾斜，kx、ky为X、Y方向上的比例。

对于矩阵不了解没关系，咱们从头学习也可以。

[矩阵](https://baike.baidu.com/item/矩阵/18069)相乘最重要的方法是矩阵乘积。只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有实际意义 。一个m×n的矩阵就是m×n个数排成m行n列的一个数阵，如果没学过矩阵的小伙伴当然目前还是一篇空白，不需要着急，我们慢慢来，如下只先看看矩阵的乘法规律：





**首先**我们必须明白在移动端，画布的默认坐标系**左上角为圆心**，**右下方向为X和Y正方向**。

在Android的画布变换中也提供了可以设置对应矩阵Matrix的数值数组float[]，大家有时间不妨可以翻看源码。对于简单的translate操作，其实就是矩阵变换的结果，当然了Google为了开发者的方便提供了简单方便的API接口。我们根据上述的规律来推导`canvas.translate(float dx, float dy)`，我们应该很清楚在二维平面内坐标系内，一个点进行平移变换，只需要在X和Y方向分别移动的距离和方向，或者通过一个向量就可以表示吧，不知道，我所说是否明确。

如下图，我们将点A[3,2]通过平移方式到A'，很早以前肯定有一堆人，研究此问题的方程，一般在我们看来，最优最快，肯定是先向右平移3个单位长度，再向下平移1个单位长度，或者先向下再向右.....。



起初，大佬们通过下面简单的表达式来表达位移运算

​                              **X‘= x+△x ，Y'=y+△y**

慢慢演变，二维平移变换通过简单的向量来计算

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NGVkNDYyYmEzMTM2NDBlZmJhZGE3YzE1MzEzOGI4ZTlfNUpCOFJYeU1Ic2pBVUlEeHdIREUxWXVkRU1MUjhHaDNfVG9rZW46Ym94Y25DS3lNd2xuUGpxclJZR3ozVWRZbnllXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

后来随着多维度的复杂计算以及简化多次元方程，数学家们朝着这个方向研究，便出现了矩阵，矩阵的出现为多维度的数学计算带来来方便，例如三维空间中的一个点我们可以表示为（**图1）**。二维空间的点，为了方便再加上一个新的维度，多出来的维度的值永远是1，点的矩阵就变成（**图2）。**也就是**齐次坐标。**

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VjM2RkNTM2NDU1OGI2ZjJiN2M1YTY0Yzk5OWI5MzdfMjFxM2dzZThZcFMxcEwyYUdnb05OMldNRGF3aDNwMnVfVG9rZW46Ym94Y25xT2ZxOTFlZ2hZMUwyRVRCNWxBSUxlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

根据平移的特性，将一个二维度的平移如下表示：

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2M2NjhmM2IwZDFkYmNkYmM5ZjdiMTE4YmU2NzAwYTZfTkNCblRuaTNBOTFuT1pWOWRQaGIwQjhQeHVNUWU0NnFfVG9rZW46Ym94Y252cXhZaDRJMW1qNVd4MnJPQ0QzVXRiXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

平移变换乘以点计算就如下：

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjg5NzJhYWZlNzA2ZDlkNzBiYWU3MjZjYTJmOGZhYTRfMDl5djA4S0tsMjhnSWJiWlRUQUxWREw0TnVXbXN5MDRfVG9rZW46Ym94Y244eXB4N1VxNjZReGtRN2J1NUprQXFmXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

到这里我们发现，事实上平移变换是矩阵计算之后的简单表示，本质还是矩阵的乘积运算。

而在自定义绘制中，为了方便简化计算和降低复杂的处理，并不是单独对点，线，面进行操作，而是对点线面所在的画布进行变换，且可以进行状态保存和恢复，让开发者能够更加方便快速的进行自定义内容。当然很多人对这段话可能不能够理解，不着急，我们慢慢来。

下图所示，我们将A点进行移动到A'，这个过程的计算不多，也不复杂。仅仅将点单独的进行了平移。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MThkNDNiNGE2MDQzY2Q5YzQ2NmFiNjAzZmI1N2ZhZTdfNnE5Uzg1aVpHaHlMNUNkMFhzTTh3UWdDcU1FMWxYb0RfVG9rZW46Ym94Y254cm5iYmZqbTBPd1p3NTBzYWNzV2FjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

如果，我们绘制了如下内容，在每个细节绘制的地方，我们是要一个个将点进行平移么？我绘制光头的眼睛，坐标系难道放到左上角进行大量眼线坐标点计算绘制么？当然不是，我希望将坐标系原点放置到眼睛左上角作为原点，鼻子相对应部分某处为原点，每个局部操作将会更加方便。这里就引出了Google为什么对画布进行平移。当然了，随着课程的深入配合对画布状态堆栈的储存与恢复，你会慢慢喜欢上画布变换，越用越爽。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM3OWZlOWM2ODBmMzExZGFkNDk2N2FiODVhZjQ3OGZfUnFxT0hCbHBjeXBpSGlzZWsxemRhREV5dElNdU5EQ2JfVG9rZW46Ym94Y25selJwVnQ0dzBqRTJFalZzTUlvOGR3XzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

似乎有点跑题了，上面我们将A点进行移动到A'，接下来我们对于画布进行平移变换如下，很明显，和单独平移点之后的屏幕位置是一样的。只是对画布进行了操作，且画布坐标系整体进行了平移变换，如下红色部分坐标系为平移变换之后的。大量的实验和操作以及表象都表明我们对于点，线，面都可以通过对画布的平移变换进行快速高效方便的等价变换，这个操作更符合我们面向画布的整体把控，而不是面向像素点的复杂操作。当然更符合CPU对于矩阵高效率的优化计算。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MDhhN2Y5NjEyODVmNGVlODQ5Y2FjMzgxMDBmYjU1OWVfOU1FTm10S3Rwd1hUTWpreW52UkRrMXFDbWhPcnZlU0hfVG9rZW46Ym94Y25CbGJmd0czRVU2YmNIa3Y3ekt1ekF3XzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)



### **画布平移变换**

`***canvas.translate(float dx, float dy)***`，控制Matrix将画布在XY二维屏幕上进行平移变换。我们上面也研究了，平移变换的本质就是矩阵变换。我们首先通过矩阵平移来将一个点平移到另一个点。对比一下Google提供的translate矩阵简单入口。

首先我们必须明白在移动端，画布的默认坐标系左上角为圆心，右下方向为X和Y正方向。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MTc3YzY0MWI3YWY4ODNjNDk3ZWYyNTg4NGY5YmJmNmNfZUZoV3dRVWdyVGhNdk40dXZKZEhSZFVMYlphT05uWTdfVG9rZW46Ym94Y24yVmJpdVA5VXJZdmJseE9qMWRoZVVkXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)



我们将点**A(100f,100f)**通过平移矩阵，向右平移**100px**，向下平移**100px**。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY3YjE5NzcxNzNiZDdlM2I3ZDUxMmI2M2ZjMDRmNzNfdmZvUFR3N1p2S2xlY3V2T3RnRXhHYXRub2FGZzMxUWxfVG9rZW46Ym94Y25zNGcwakgwSVFaam90cGczYXZSOHRmXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

Android提供的**Matrix**通过一个数组进行表示如下：

应该很容易看出来，横着从上往下排列即可。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YWE2MTM0M2M0YTdlM2I0NDgxMGExZDc0M2FkMTY5OWFfQVdQS1dHVmlDSXRGYUdkbGhlRXVGOGZPWVBGSG5tR1lfVG9rZW46Ym94Y25sbHk4UWVXTnFlVnU4eUxMM3U0aXBlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

```Kotlin
val matrix = Matrix()

matrix.setValues(

floatArrayOf(

1f, 0f, 100f, 

0f, 1f, 100f,

0f, 0f, 1f))
```

如下代码:

```Kotlin
///Users/wangfeiwangfei/wangfei/GitHub/draw_android/app/src/main/java/com/example/draw_android/section05_canvas/a_translate/CanvasTranslateView.kt

class CanvasTranslateView constructor(context: Context, attributeSet: AttributeSet) :

    View(context, attributeSet) {

    init {

    }

    override fun onDraw(canvas: Canvas) {

        super.onDraw(canvas)

        val hSize = height / 100

        val wSize = width / 100

        //画网格

        drawScale(canvas, hSize, wSize)

        //绘制点

        canvas.drawCircle(100f, 100f, 20f, Paint().apply {

            color = Color.BLACK

            style = Paint.Style.FILL

            isAntiAlias = true

        })

        //创建矩阵

        val matrix = Matrix()

        matrix.setValues(

         floatArrayOf(

         1f, 0f, 100f,

         0f, 1f, 100f, 

         0f, 0f, 1f))

        canvas.setMatrix(matrix)

        canvas.drawCircle(100f, 100f, 20f, Paint().apply {

            color = Color.RED

            style = Paint.Style.FILL

            isAntiAlias = true

        })

    }

    //这部分作为参考，辅助网格线，没必要有压力，我们慢慢来。 

    private fun drawScale(canvas: Canvas, hSize: Int, wSize: Int) {

        //画竖线

        canvas.save()

        for (index in 0 until hSize) {

            canvas.drawLine(0f, 0f, width.toFloat(), 0f, Paint().apply {

                color = Color.GRAY

                strokeWidth = 5f

            })

            canvas.translate(0f, 100f)

        }

        canvas.restore()

        //画横线

        canvas.save()

        for (index in 0 until wSize) {

            canvas.drawLine(0f, 0f, 0f, height.toFloat(), Paint().apply {

                color = Color.GRAY

                strokeWidth = 5f

            })

            canvas.translate(100f, 0f)

        }

        canvas.restore()

    }

}
```

我们将点从A(100px，100px)移动到了A'(200px,200px)的位置。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NjIxMjc2YTE3ODZmZjU0OGU2NGJlZTQ0ZTE5YmIyODhfOUZQVllnVGdlR2ZWT2RoMzY3dWpBQXBBWDM3b0Vsa0xfVG9rZW46Ym94Y25DWnNBcmYxRWFNMnVLRERNV2FUb0pjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来，我们用Google提供的translate进行平移变换，看看效果。

```Kotlin
我们只是将Matrix()换成了简单的translate了，但结果是完全相同的，

大家如果不想看源码可以大胆的猜想一下translate干了啥。

//val matrix = Matrix()

//matrix.setValues(floatArrayOf(1f, 0f, 100f, 0f, 1f, 100f, 0f, 0f, 1f))

//canvas.setMatrix(matrix)

canvas.translate(100f,100f)
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NjIxMjc2YTE3ODZmZjU0OGU2NGJlZTQ0ZTE5YmIyODhfOUZQVllnVGdlR2ZWT2RoMzY3dWpBQXBBWDM3b0Vsa0xfVG9rZW46Ym94Y25DWnNBcmYxRWFNMnVLRERNV2FUb0pjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

毫无疑问平移变换是矩阵变换中最常用的。接下来我们根据实际案例一起深入了解一下，平移变换在绘制中的使用场景及其重要性。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MmM0NDFjNmY4YmE2N2U1NGIxNTZmYzdlZGMxNGY2ZDRfZHhtNFNwY3AxZTF3U3A2QjJ3d2hZUjRxR244SldKQ0JfVG9rZW46Ym94Y240ME5ONjJWcXBBVWVQbEN1UDBXU2piXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

例如上面[Echarts](https://echarts.apache.org/examples/zh/index.html#chart-type-lines)里面的图表，如果没有浏览过可以看看[Echarts官方网站](https://echarts.apache.org/examples/zh/index.html#chart-type-lines)，很多的图表库为了很好的表达实际的数据趋势和用户体验，都会有水平和垂直的刻度轴，接下来我们简单的了解一下刻度轴。如下图，我们可以看到水平坐标轴都是不同的刻度线和文字组成。且是平均按照一定的间隙分布。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ0NTFlOGQyNzViMTM0OTdkZmMyMmQ5ZWMyODc3ZjVfM04xODhzWUFvMkhxY2NDWEphMEY2Qkt5dVRuNXBVNU5fVG9rZW46Ym94Y24wcHd3andTbzBaT3FDRkxxcE1mRGtnXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

我们每个人都想一下，如果没有画布的平移，你会如何绘制这个水平刻度轴？是不是先计算出这条横线的位置绘制，然后再计算第一个刻度线进行绘制，然后计算第二个刻度线的位置，接着绘制第二个刻度线，以此类推。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MjVmOWQ1MGQwOTlmYzc4ZDA2Nzg5NjY1NGNkZjRiMTJfSjEyVVFTQU4xR1JFenZsN0RJMVp0VndZdkxvVlJJbzFfVG9rZW46Ym94Y25kZWkxSmdjYzFEQ3NzU0s4Wk8yNVRiXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YjAyMjM3ZWFiZjgwMjQ3Njg3MDdjMTI5NGZhNmRiYTlfVldWeldUQlRxVkJXVm1KcHAydm1RM3BaUm16b3JqdjhfVG9rZW46Ym94Y24zSVZ4dk9saEMyWGJGSklJQlNRdUNjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来根据上图进行代码分析过程和代码编写：

**首先**需要了解一下Canvas提供的绘制线段的方法，`public void drawLine(float startX, float startY, float stopX, float stopY, @NonNull Paint paint)`， 通过起始点和结束点绘制一条线段。

- 坐标圆点在左上角，屏幕高度为height，宽度为width。
- 我们需要在屏幕中间绘制一条横线。距离屏幕左右为50px的距离。起始点和结束点的坐标为多少呢？相信这个不难算出 startX =  50f，startY =height /2f ，stopX =width - 50f ，stopY = height /2f。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NWRhZDU1ZWY1MGY5NmZkNTJmZDRlM2RkOTBkNWNiMmFfS3QwTExyVUxKM0dSeERoQk5XSDZWSlNBMDFTeGZMTGRfVG9rZW46Ym94Y241ZDVHRXZZNUh1UWpDOHpGbjFWRW5jXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

代码如下：

```Kotlin
///Users/wangfeiwangfei/wangfei/GitHub/draw_android/app/src/main/java/com/example/draw_android/section05_canvas/a_translate/CanvasTranslateView2.kt

package com.example.draw_android.section05_canvas.a_translate



import android.content.Context

import android.graphics.Canvas

import android.graphics.Color

import android.graphics.Matrix

import android.graphics.Paint

import android.util.AttributeSet

import android.view.View



/**

 * Created by wangfei44 on 2022/1/26.

 */

class CanvasTranslateView2 constructor(context: Context, attributeSet: AttributeSet) :

    View(context, attributeSet) {

    var mWidth = 0

    var mHeight = 0

    val paint = Paint().apply {

       color = Color.BLACK

       strokeWidth = 10f

       style = Paint.Style.STROKE 

    }

    init {



    }



    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {

        super.onSizeChanged(w, h, oldw, oldh)

        //这里目前作为了解:

        //当View大小发生变化或者初始化首次也会调用。这个调用在onDraw之前所以只要测量绘制过程中没有

        //发生大小改变那么在onDraw里面直接拿width和height也可以用，所以有很多开发场景中直接

        //在onDraw里面使用 height 和 width 应该杜绝。

        mWidth = w

        mHeight = h

    }

    override fun onDraw(canvas: Canvas) {

        super.onDraw(canvas)

        //1.我们明白坐标圆点默认在左上角。接下来我们计算横线的起点和终点坐标。

        val startX = 50f

        val startY = mHeight/2f

        val stopX = width - 50f

        val stopY = mHeight/2f

        canvas.drawLine(startX,startY,stopX,stopY,paint)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MjMxZGMxMjFhZjIzYWEwOWUzNWE2N2RmYjg5NDJhY2RfVG9pWnU3Smlpak4xMkNFSDRia1I0aXBoZEt4T2s2V3pfVG9rZW46Ym94Y25EN3VrbW5xNkpiVEJ0OWxGSTg4ckJlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

- 第一个刻度的起始点和结束点，我们默认刻度长度为20px，一般不难得出scaleStartX = 50f，scaleStartY = height / 2f - 20f ，scaleStopX = 50f，scaleStopY = height / 2f，一般开发者可能到这里就忽略了细节之处，但是自定义绘制如果追求完美，应该来说目前这个计算是有问题的，当你的画笔比较粗时候是可以看出来的。我们当前设置的画笔宽度 = 10px应该可以看出来的。代码和图如下

```Kotlin
override fun onDraw(canvas: Canvas) {

    super.onDraw(canvas)

    //1.我们明白坐标圆点默认在左上角。接下来我们计算横线的起点和终点坐标。

    val startX = 50f

    val startY = mHeight / 2f

    val stopX = width - 50f

    val stopY = mHeight / 2f

    canvas.drawLine(startX, startY, stopX, stopY, paint)

    

    //2.计算第一个刻度

    val scaleStartX = 50f

    val scaleStartY = height / 2f - 20f

    val scaleStopX = 50f

    val scaleStopY = height / 2f

    canvas.drawLine(scaleStartX, scaleStartY, scaleStopX, scaleStopY, paint)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M5ZjhmM2FkZjk4M2EzZGRmYjljMWQ1NDA4MmY5MGZfRk0yR3UyYzJobkV0QUFWanA1M3ZBMDdJTm9qRUVPVHRfVG9rZW46Ym94Y25RUW9EZ0RZaTBPNlJSNEU0U2tYczdMXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

我们通过AndroidStudio 日志面板screen capture功能可以获取截图，我们通过放大按钮可以查看细节，当我们放大到一定倍数之后可以清晰看到我们刻度线的一半偏左了。我们在第二节课中讲解Paint的类型时候就详细讲解了，如果需要精细的绘制且画笔宽度到达一定宽度时候必须考虑画笔的宽度。我们很容易得出实际的第一个刻度的横坐标应该加上画笔宽度的一半。

```Kotlin
//2.计算第一个刻度

val scaleStartX = 50f + paint.strokeWidth / 2f//当画笔宽度到达一定的宽度，对绘制结果有所影响时需要考虑画笔宽度

val scaleStartY = height / 2f - 20f

val scaleStopX = 50f + paint.strokeWidth / 2f

val scaleStopY = height / 2f

canvas.drawLine(scaleStartX, scaleStartY, scaleStopX, scaleStopY, paint)
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg0ZjFiMGE5Mjk4MjJlMWM3NzM4Yjc4Mjk1ODM0ZThfcFhhNEs4ZzFPV3g3WlNScDhGM0VlbTBWQ2NxcUZVSmZfVG9rZW46Ym94Y25MZk5pTzBxZnFOZURvbU1GSnA1enRjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

水平方向我打算绘制6个刻度，那每个刻度之间的间距是多少呢？如果你愿意慢下来画图应该会很容易发现绘制规律。

```Kotlin
val scaleWidth = (mWidth - mMargin * 2 - paint.strokeWidth) / 6

for (index in 0 until 7){

    val scaleStartX1 = 50f + paint.strokeWidth / 2f + scaleWidth*index

    val scaleStartY1 = height / 2f - 20f

    val scaleStopX1 = 50f + paint.strokeWidth / 2f + scaleWidth*index

    val scaleStopY1 = height / 2f

    canvas.drawLine(scaleStartX1, scaleStartY1, scaleStopX1, scaleStopY1, paint)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgwNDMyNGM0MDllMTI1MTM3MjNhZTZiOTQ3NDYyM2NfRFVVY1IwbEVheURTM2VyT3lxSFBvek01aXkzd2I5eGhfVG9rZW46Ym94Y25yYjNqQTNGR1FKc0NjaG1oWkowcXVjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来如果想在刻度线的正下方200像素地方继续绘制这个刻度线。我们还需要复杂的计算位置。那有没有简单的做法，当然有，也就是画布的平移变换，步骤和代码如下：

 **canvas.translate(0f,200f)将坐标系向下平移200px，这时候画布的坐标圆点为图中第二个，再次进行前面重复绘制得到图三**。

我们需要明白，画布的平移是整体平移画布，圆点会根据平移进行变换。所有的画布的每一个像素点都有着同画布一样的平移变换

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk2MDEwOGY0N2M1ZjUwZTE1N2RiYjg5MjE0NWY5MjVfZWo4RVlHY3dJbW1MOFprRFcwRVM4V3ZhV0I4YUVnZlpfVG9rZW46Ym94Y244NlBHR09WYWNKUk5ES1NMZ2MyRHFiXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

```Kotlin
1，绘制X轴横线

2，绘制刻度

3，向下平移画布

4，重复1，2代码进行绘制横线和刻度即可
//1，绘制X轴横线

canvas.drawLine(startX, startY, stopX, stopY, paint)

val scaleWidth = (mWidth - mMargin * 2 - paint.strokeWidth) / 6

//2，绘制刻度

for (index in 0 until 7){

    val scaleStartX1 = 50f + paint.strokeWidth / 2f + scaleWidth*index

    val scaleStartY1 = height / 2f - 20f

    val scaleStopX1 = 50f + paint.strokeWidth / 2f + scaleWidth*index

    val scaleStopY1 = height / 2f

    canvas.drawLine(scaleStartX1, scaleStartY1, scaleStopX1, scaleStopY1, paint)

}

//3，向下平移画布

canvas.translate(0f,200f)

//4，重复1，2代码进行绘制横线和刻度即可

canvas.drawLine(startX, startY, stopX, stopY, paint)

for (index in 0 until 7){

    val scaleStartX1 = 50f + paint.strokeWidth / 2f + scaleWidth*index

    val scaleStartY1 = height / 2f - 20f

    val scaleStopX1 = 50f + paint.strokeWidth / 2f + scaleWidth*index

    val scaleStopY1 = height / 2f

    canvas.drawLine(scaleStartX1, scaleStartY1, scaleStopX1, scaleStopY1, paint)

}
```

整合代码如下比较优雅：

```Kotlin
private fun drawTranslateLine(canvas: Canvas) {

    val startX = mMargin

    val startY = mHeight / 2f

    val stopX = width - 50f

    val stopY = mHeight / 2f

    //1,绘制横线

    canvas.drawLine(startX, startY, stopX, stopY, paint)

    //2,绘制刻度线

    drawScaleLine(canvas)

    //3,变换画布

    canvas.translate(0f,200f)

    //4,绘制新内容

    canvas.drawLine(startX, startY, stopX, stopY, paint)

    drawScaleLine(canvas)

}



private fun drawScaleLine(canvas: Canvas) {

    val scaleWidth = (mWidth - mMargin * 2 - paint.strokeWidth) / 6

    for (index in 0 until 7) {

        val scaleStartX1 = 50f + paint.strokeWidth / 2f + scaleWidth * index

        val scaleStartY1 = height / 2f - 20f

        val scaleStopX1 = 50f + paint.strokeWidth / 2f + scaleWidth * index

        val scaleStopY1 = height / 2f

        canvas.drawLine(scaleStartX1, scaleStartY1, scaleStopX1, scaleStopY1, paint)

    }

}
```

在这个绘制过程我们明显感觉到了画布的变换能极大的减少开发者的计算，提高自定义绘制的效率，让复杂的绘制过程简化。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZlMjNmODdjNmEwMjYzZDM5NjZmOTgxYzU5YzFmZmVfMWZSZjA2cGJrYWVtR3RhamhRY1RlSkNnMUpTaHRaNERfVG9rZW46Ym94Y241NE1nSHVFbDB2UXdoQ09TNlV1dTFnXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

到这里我们需要知道，画布的平移变换，可以让我们轻松简单的去处理一些整体的变换，也可以让我们更加方便的操作局部绘制，如下，当我们绘制人物或者建筑，花草等比较复杂的东西时候，我们每绘制一个局部，我们只需要将坐标系变换到我们需要细节处理的局部，这样对于我们的坐标参考系和绘制过程起到了很大的作用。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ODhhNTk0YjhkN2U0YmMwOWEzMzkzMGU5YzFjZmM3NDhfVkN3MXpld2MzdFV5eVFjSDVYNERDU3ZhYlNjamsyWGpfVG9rZW46Ym94Y25JVlpsamJrR0wyS2pMRkNRMnhBU0pjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

当然到这里，可能很多人还是比较模糊，咋么就提高效率呢，咋么就方便呢？我们小册整个过程中都会伴随着画布的变换所以不用着急。

### **画布旋转变换**

`***canvas.rotate(float degrees)或rotate(float degrees, float px, float py)***`，控制Matrix将画布在XY二维屏幕上进行旋转变换。相对于旋转的矩阵公式，我们再来推导一下。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=N2IxY2IwOWMyMjVmYjdiNzBiYmYxZGU5OGU3ZWVjMDdfSW5XYmx2MVh3NlV0ZU9jM2U0OThKbHhMY0xHUlpnTFBfVG9rZW46Ym94Y25rOHVaSTlLUndnMUFab2pIMVdQa1N6XzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

如下，我们将黑色长方形逆时针旋转角b到绿色长方形地方，R为长方形的长，我们通过正余炫函数可以轻松证明出二维平面内旋转变换的方程，以及矩阵方程式。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MThkZWY0Y2VmNmE2NDYwMzE5YzdkODlhZTkyZTdhZTVfYVpMUXJqU1BIVnlzMGVRUTJlbEdMZlBtOXFqYnNaN2RfVG9rZW46Ym94Y25QaFllWTBqNTUyb1dTUzN2Mm5ObTVlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

那旋转变换都在那些实际开发场景中使用呢？接下来我们看看常见的一些代表案例。

**华为手机系统工具**闹钟里面的**时钟**，**秒表**，**倒计时**界面。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ODM2OTA1Y2FlNWM2NGY3MjJlMDQ4YmQ0OGQ4MTczMmJfaVhzUmh2STdWWGZiTkJ0eWpSMU1keHB1VE9uazVPM2JfVG9rZW46Ym94Y25ZU0hSeDlzRkhQSDdjM2hVTEFla3hlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

**华为手机系统工具指南针**里面的**指南针**和**水平仪**界面。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MTllYjJlZjhhOWVlOTY1NmRhY2ZkNzQwZDE4OTkzOTlfV1dGS3d4NDZvZHdUNWYxbDVLb3pTZm4wRVZWSXNyMVNfVG9rZW46Ym94Y25ZRU5iWlZ1RTl1QkRzUktlQjB2Z3VlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

**Echars**官方的各种**饼图**。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U3OWZmMDRlODAzYzNiYzVjNjA1Mzc1YmQ1OTg4YzdfVjVyMW1kZ1R6MENJcHN3eG1PeGlkSmxsVk5qQXdOd3BfVG9rZW46Ym94Y25pcDBOSGQwUnczWWJXa0VFeFZMVjJjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

很多应用都随处可见自定义旋转的UI，大家不用着急，画布的变换在后面章节随处可见，这节课我们作为了解，当然了动手一遍最好。

到这里我们必须明确画布的旋转变换，其变换的前后都是针对画布旋转变换，而画布上的内容是由于画布变换所以整体跟随变换。

### **华为表盘案例**

我们不妨先用目前已经学到的平移变换和旋转变化感受一波华为表盘吧

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdiOWMyZDRkMzQ1ZGM5ZDNkZmJhNDM1MTI4NzY1NzBfSFBjRlF2d2NkV0Zia2xDdE8yQVc0QVhIemJJSjJWUDRfVG9rZW46Ym94Y25USkh1Vzhpd2JwU3A3cmF5VGZGdk05XzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

**分析绘制元素：**

- 表盘背景是一个圆形图片，暂且我们用圆来表示，后面学到绘制图片之后我们继续完善。
- 表盘有12个小时刻度。
- 表盘有60个秒钟刻度。
- 表盘有三个指针

**分析绘制坐标系：**

整个表盘都是围绕表盘中心旋转，最好将坐标系通过平移变换到表盘中心，我们表盘绘制放到View中心。相信大家对于画布平移变换比较了解了吧。View的宽为width，高为height那么我们可以通过下面变换将画布坐标圆点平移到View中心。

```Kotlin
///Users/wangfeiwangfei/wangfei/GitHub/draw_android/app/src/main/java/com/example/draw_android/section05_canvas/b_rotate/CanvasRotateView.kt

package com.example.draw_android.section05_canvas.b_rotate



import android.content.Context

import android.graphics.Canvas

import android.graphics.Color

import android.graphics.Paint

import android.util.AttributeSet

import android.view.View



/**

 * Created by wangfei44 on 2022/1/26.

 */

class CanvasRotateView constructor(context: Context, attributeSet: AttributeSet) :

    View(context, attributeSet) {

    var mWidth = 0

    var mHeight = 0

    val paint = Paint().apply {

        color = Color.BLACK

        strokeWidth = 10f

        style = Paint.Style.STROKE

    }



    init {



    }



    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {

        super.onSizeChanged(w, h, oldw, oldh)

        //这里目前作为了解:

        //当View大小发生变化或者初始化首次也会调用。这个调用在onDraw之前所以只要测量绘制过程中没有

        //发生大小改变那么在onDraw里面直接拿width和height也可以用，所以有很多开发场景中直接

        //在onDraw里面使用 height 和 width 应该杜绝。

        mWidth = w

        mHeight = h

    }



    override fun onDraw(canvas: Canvas) {

        super.onDraw(canvas)

        //平移画布中心到屏幕中心

        canvas.translate(mWidth / 2f, mHeight / 2f)

        //绘制圆心点

        canvas.drawCircle(0f, 0f, 10f, paint)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MThlMWU4Yjg0ZDJhODE4ZTU1ZjYzN2Q3NWMzZTc5ZjRfdGRKYVJhbFpuOUhOblFBZ3FNQWo0V3BXdWl0eEtaemFfVG9rZW46Ym94Y25lOTJXNjBvcHladU91cTNKYk5iYU9nXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

我们先绘制一个圆圈作为表盘背景，等后面我们学到其他API时候再丰富表盘背景。所以对于drawCircle这个API我们先来了解一下。设置圆心坐标，半径为radius绘制圆圈。

```Kotlin
canvas.drawCircle(float cx, float cy, float radius, @NonNull Paint paint)
```

我们设置表盘的半径为View宽度的三分之一，再通过画笔setShadowLayer设置阴影，为了让四周都出现阴影，我们需要绘制两个底部圆圈，一个圆圈右下角阴影，一个圆圈左上角阴影。

```Kotlin
private val paintShadowLayerTop = Paint().apply {

    color = Color.parseColor("#E5E7EB")

    strokeWidth = 10f

    style = Paint.Style.FILL

    setShadowLayer(20f, 20f, 20f, Color.parseColor("#F5F7F6"))

}

private val paintShadowLayerBottom = Paint().apply {

    color = Color.parseColor("#E5E7EB")

    strokeWidth = 10f

    style = Paint.Style.FILL

    setShadowLayer(20f, -20f, -20f, Color.parseColor("#F5F7F6"))

}



override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {

    super.onSizeChanged(w, h, oldw, oldh)

    //这里目前作为了解:

    //当View大小发生变化或者初始化首次也会调用。这个调用在onDraw之前所以只要测量绘制过程中没有

    //发生大小改变那么在onDraw里面直接拿width和height也可以用，所以有很多开发场景中直接

    //在onDraw里面使用 height 和 width 应该杜绝。

    mWidth = w

    mHeight = h

    paint.shader = RadialGradient(

        0f,

        0f,

        mWidth / 3f,

        Color.parseColor("#EFF1F1"),

        Color.parseColor("#E5E7EB"),

        Shader.TileMode.CLAMP

    )

}





override fun onDraw(canvas: Canvas) {

    super.onDraw(canvas)

    canvas.translate(mWidth / 2f, mHeight / 2f)

    //为了好看，绘制一个同样大小的表盘设置左上部分的边缘阴影

    canvas.drawCircle(0f, 0f, width / 3f, paintShadowLayerTop)

    //为了好看，绘制一个同样大小的表盘设置右下部分的边缘阴影

    canvas.drawCircle(0f, 0f, width / 3f, paintShadowLayerBottom)

    //绘制最顶层的表盘

    canvas.drawCircle(0f, 0f, width / 3f, paint)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U0ZGY2ODc2MTRmMDRiYzA1OTIyMDJhODVhMzBhOWFfSWJWOXloalFHYzBsaDNHalNvRGFPQmVxUU54TGpJYWNfVG9rZW46Ym94Y25MajVSWHZVMVk3enRPTm1JMmJMRUxnXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来我们进行绘制刻度，首先绘制60个秒针刻度。坐标系目前如下图所示，我们先绘制12点钟方向的刻度线。我们使秒针刻度距离表盘边缘为30像素，秒针刻度高度为25，那么12点秒针刻度绘制起点为(x1,y1)= (0，-R+30)，终点坐标为（0，-R+30+25）。当然我们可以看到刻度端头都是有弧度的。我们可以将前面课程学到的知识都利用起来，***strokeCap*** **= Paint.Cap.*****ROUND****。*

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY0NGExMzkzOTlhMjlhYjZlOWJhZGQxNTk1OGY4ZjBfaXpzZVM2VWJJM0ZtOEhYZEdOeTZiZmJPODZEdGE0SndfVG9rZW46Ym94Y25EQmRMMjRFSGNTWVl1M3RXNUZIbm9VXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTgxNDRiYTE1OGQyZjA2NTJhOTY5YjhhNDFhNGMyYWZfOUdVVGRPcnVmM2JZOUZSUTU1Z3VMTVhTREoyOUJtczhfVG9rZW46Ym94Y25JNUFtTldwSlA2TG4ybENwaWRTQzZnXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

```Kotlin
private val secondPaint = Paint().apply {

    color = Color.parseColor("#B3B6C9")

    strokeWidth = 5f

    style = Paint.Style.FILL

    strokeCap = Paint.Cap.ROUND//前面小结学到的，都加上看看效果。

}

private fun drawSecondScale(canvas: Canvas) {

    //1.(x1,y1)= (0，-R+30)，终点坐标为（0，-R+30+25）

    val R = width / 3f

    val startX = 0f

    val startY = -R + 30f

    val endX = 0f

    val endY = -R + 30f + 25f

    canvas.drawLine(startX, startY, endX, endY, secondPaint)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NWI4MzAwMzRjOTkwZDljZTMzNDEyZjFjZTZjN2Q3NGRfWG9rU1V1eXFsQUQzR1pzQXVjQ1Rxa3lFSUh2WlNsYWZfVG9rZW46Ym94Y241OElmQnlQMHFQZ1ZGZFZGeHNqS1dWXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

我们需要绘制60个秒针刻度，我们坐标轴在表盘圆心，我们只需要将表盘每旋转360度/60 = 6度，然后绘制一个刻度即可得到所有的秒钟刻度。

```Kotlin
private fun drawSecondScale(canvas: Canvas) {

    //1.(x1,y1)= (0，-R+30)，终点坐标为（0，-R+30+25）

    for (index in 0 until 60){

        val R = width / 3f

        val startX = 0f

        val startY = -R + 30f

        val endX = 0f

        val endY = -R + 30f + 25f

        canvas.drawLine(startX, startY, endX, endY, secondPaint)

        canvas.rotate(6f)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTZhNTI2MWM1MGM2MzVmZmI5NjdmMGY0MjVhODJmMDhfaGhYYkNQMVZsOGJGWTJ4eml2UTJscG56akIxUVRINEpfVG9rZW46Ym94Y243MlFxODV5MjkySDhualJYU1ZobGJlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

同样时针每30度绘制一个刻度，刻度线稍粗且稍长，线粗细设为8像素，长度为35像素，我们绘制代码如下：

```Kotlin
private val hourPaint = Paint().apply {

    color = Color.parseColor("#B3B6C9")

    strokeWidth = 8f

    style = Paint.Style.FILL

    strokeCap = Paint.Cap.ROUND

}

//绘制小时刻度

private fun drawHourScale(canvas: Canvas) {

    for (index in 0 until 12){

        val R = width / 3f

        val startX = 0f

        val startY = -R + 30f

        val endX = 0f

        val endY = -R + 30f + 35f

        canvas.drawLine(startX, startY, endX, endY, hourPaint)

        canvas.rotate(30f)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgwNmNjZTY2ZjZiNDU4YjUxOWFkMjE4ZmQxYzZjMWVfeVZiaVZYbkU2dHNxdTF1bXJrSEZweHlSZTk2RlhLTmFfVG9rZW46Ym94Y25zQmxPM1J2UVdIT3pwTUtITGpLSUFjXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来我们绘制文字，那我们就需要了解一个简单的绘制文字的API。用来绘制文字，在坐标（x,y）处绘制文字text。

```Kotlin
drawText(@NonNull String text, float x, float y, @NonNull Paint paint)
```

我们在绘制刻度时候，在其下方30像素的地方通过drawText(...)粗略的绘制刻度数字，接下来我们看看代码：

```Kotlin
//绘制小时刻度

private fun drawHourScale(canvas: Canvas) {

    for (index in 0 until 12) {

        val R = width / 3f

        val startX = 0f

        val startY = -R + 30f

        val endX = 0f

        val endY = -R + 30f + 35f

        canvas.drawLine(startX, startY, endX, endY, hourPaint)

        canvas.rotate(30f)

        //刻度绘制文字

        canvas.drawText((index + 1).toString(), endX-16f, endY+30f, textPaint)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NWM2OTQ0YmEyYmExOTVjMjcxYWI3YzZjZDE4YzBiYzdfbU5OS3FQUkhoZUl5Z1pDZHR2UHFUeDhpSEVsM2ZlY1dfVG9rZW46Ym94Y25qTXROU29hZm5hMnhUQTNEbGpXOTBlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

根据上面的图，我们可以看到一个比较丑的表盘，瑕疵较多，数字绘制位置一点不严谨，并不是每一个数字都和刻度中心对齐，且数字显示和华为表盘并不一致。首先有两个问题，一是数字和刻度中心不对齐，二是数字和华为显示不一致。

数字和刻度中心不对齐，我们需要测量刻度文字的宽度然后来设置绘制文字的起始点。首先需要了解一个测量文字的相关知识。

```Visual%20Basic
Paint拥有两个可以测量文字宽度的方法。

1.float measureText(String text)，返回text的宽度。

2.public void getTextBounds(String text, int start, int end, Rect bounds)

返回text的bounds，可以字符串的获取宽和高。
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YjkyZWVjMjM4ZTZjNzNiNThmZDE1Y2U5MGNiZmJkMDNfd0EyOHNNajAzcVVTMXlSVFpOeGhCUFdwYWJhdGJIM01fVG9rZW46Ym94Y25yQTNKbXZ2a3FvdHlTSFZCb1daWTNkXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

上图不难看出，文字绘制的起始点x = startY - textWidth / 2f

```Kotlin
//绘制小时刻度

private fun drawHourScale(canvas: Canvas) {

    for (index in 0 until 12) {

        val R = width / 3f

        val startX = 0f

        val startY = -R + 30f

        val endX = 0f

        val endY = -R + 30f + 35f

        canvas.drawLine(startX, startY, endX, endY, hourPaint)

        canvas.rotate(30f)

        //刻度绘制文字

        val text = (index + 1).toString()

        //val textWidth = textPaint.measureText(text)

        val rect = Rect()

        textPaint.getTextBounds(text, 0, text.length, rect)

        canvas.drawText(

            (index + 1).toString(),

            startX - rect.width()/2f,//手动画一下，startX为12点刻度减去文字的一半就是文字起始的X

            endY + 20f + rect.height(),//文字在刻度下面，至少文字高度的地方，且给了20像素的空间

            textPaint

        )

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NGYxNTc4OTNkZjAzNDNlMzAxNTEyZjVlMGI3MjJkNTlfc2lPNkdqR1p4WU5QNUNhcWZ6UzFET01sVVI1QklsNm1fVG9rZW46Ym94Y25lOUczQmFidFNmMjFZR3FSR1BVcHVlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

到这里，我们这个表盘刻度看着比较舒服了吧。但是文字还是有旋转的，我们能不能都和华为表盘一样都竖着呢，当然可以，这就涉及到这节课的下一个知识点画布状态的保存和恢复。对于局部的数字进行局部处理。不用着急，这节课会解决这个问题的，当然了也会完善各个时间针的。

### **画布缩放变换**

既然我们学习了平移变换和旋转变换，接下来我们先将坐标系平移到屏幕中心。绘制一个X轴和Y轴，以及在绘制两个箭头。

```Kotlin
package com.example.draw_android.section05_canvas.c_scale



import android.content.Context

import android.graphics.*

import android.util.AttributeSet

import android.view.View



/**

 * Created by wangfei44 on 2022/1/26.

 */

class CanvasScaleView constructor(context: Context, attributeSet: AttributeSet) :

    View(context, attributeSet) {

    private var mWidth = 0

    private var mHeight = 0

    val paint = Paint().apply {

        color = Color.BLACK

        strokeWidth = 5f

        style = Paint.Style.FILL

        isAntiAlias = true

    }



    init {



    }



    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {

        super.onSizeChanged(w, h, oldw, oldh)

        //这里目前作为了解:

        //当View大小发生变化或者初始化首次也会调用。这个调用在onDraw之前所以只要测量绘制过程中没有

        //发生大小改变那么在onDraw里面直接拿width和height也可以用，所以有很多开发场景中直接

        //在onDraw里面使用 height 和 width 应该杜绝。

        mWidth = w

        mHeight = h

    }



    override fun onDraw(canvas: Canvas) {

        super.onDraw(canvas)

        drawXY(canvas)

    }



    private fun drawXY(canvas: Canvas) {

        //1.将圆心平移到屏幕中心

        canvas.translate(mWidth / 2f, mHeight / 2f)

        //2.绘制X轴

        canvas.drawLine(-mWidth / 2f, 0f, mWidth / 2f, 0f, paint)

        //3.绘制X轴的箭头，可以想一想箭头起点为X轴的端点，结束点X都是偏左，Y上下一定的距离即可。

        canvas.drawLine(mWidth / 2f, 0f, mWidth / 2f-20,10f, paint)

        canvas.drawLine(mWidth / 2f, 0f, mWidth / 2f-20,-10f, paint)



        //3.绘制Y轴

        canvas.drawLine(0f, -mHeight / 2f, 0f, mHeight / 2f, paint)

        //2.绘制Y轴箭头

        canvas.drawLine(0f, -mHeight / 2f, 20f, -mHeight / 2f+20, paint)

        canvas.drawLine(0f, -mHeight / 2f, -20f, -mHeight / 2f+20, paint)

    }

}
```

结合下图，相信对于箭头的绘制，应该胸有成竹。已知端点的坐标，箭头的末尾点X轴对称，应该来说自行脑补就可以写出来，当然画图更清晰明了。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NTY0OTQ0ZDQ0OWMxZmQ0MmY4YWMyMjljNDZhOGNkOTZfQTFhZFEyWHJIZGUybDV4UDFFOGN1dzhYd2tvYzlFWW9fVG9rZW46Ym94Y25SNDdGMHBPeE96d2tyVXp3Y0xOWHZlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

我们先来看看提供开发者关于缩放的方法**public void scale(float sx, float sy)** ，可以通过此方法，将画布进行缩放。sx即使其X轴方向放大sx倍数，sy使其Y轴方向放大sy倍数。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGVmZGNmODYzZmZlMjNkN2Q4YTBkNWU0OGI5MGQwOWVfNHM2T1VyeEVPY253ZFl5Wlh5c1RFRkZCUTd1cEcyOXJfVG9rZW46Ym94Y24wVWxwODJXUzlDTnZSa2p0MU80b2toXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来，我们分别在坐标中心绘制不同画布旋转之后的效果，来看看画布的缩放变换是多么的简单。

```Kotlin
//图1

private fun canvasScale(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.x轴和y轴缩放比例都是1，也就是不缩放。

    canvas.scale(1f,1f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}





//图2

private fun canvasScaleY(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.x轴比例是1，2轴放大2倍。

    canvas.scale(1f,2f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}





//图3

private fun canvasScaleX(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.y轴比例是1，X轴放大2倍。

    canvas.scale(2f,1f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}



//图4

private fun canvasScaleXY(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.x轴和y轴缩放比例都是2。

    canvas.scale(2f,2f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}



//图5

private fun canvasScaleBurdenXY(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.x轴-1，y轴缩放比例都是1。

    canvas.scale(-1f,1f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}



//图6

private fun canvasScaleXBurdenY(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.x轴和y轴缩放1，-1。

    canvas.scale(1f,-1f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}



//图7

private fun canvasScaleBurdenXBurdenY(canvas: Canvas) {

    //1.在圆心处绘制一个半径为100像素的圆圈

    canvas.drawCircle(0f,0f,100f,circlePaint)

    //2.x轴和y轴缩放比例都是-1。

    canvas.scale(-1f,-1f)

    //3.在坐标系200像素，200像素的地方绘制一个半径为30的圆，作为参考系。表示(200,200)表示正方向。

    canvas.drawCircle(200f,200f,30f,circleScaledPaint)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE4ODQ2NTQzZmE1YjlmZmE5N2I1NTg0MmI3OThiZTlfMXRSMVlpZkRlcmJzSGNDMktQVDNHRnVORGV1NHp1WUxfVG9rZW46Ym94Y24zV1ZubTkxOHVHUDBVd1kxaTFMNVRlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQzMTVmNzExNDM1NDNkOGM3MDc3YmE0ZmE1MzM3ZDdfdG03YkowcVQ0SjFGTVU0dnprTEFDNGhNWk1nbEpaZFZfVG9rZW46Ym94Y25BN29CdG5PV0Jsc0pHQVN5cFZ2bUdiXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

由上图，我们可以看到**scale(float sx, float sy)**可以在X和Y轴方向进行缩放，且当sx和sy为-1时，会在对应的方向上沿着圆心竞相翻转，而sx和sy设置竞相翻转，也是我们自定义过程中很常用的画布变换。默认画布坐标系是左上角为圆心，右下角为正方向，相反我们比较熟悉的坐标系都是右上角为正方向且圆点不在左上角。

如下图一，图二等在互联网中常见的一些图表，一般都可能是左下角为圆心，右上角作为正方向。这里严格的只能说可能，当然了如果你的计算力和脑力比较强大完全可以任意点为圆心，任意方向为正方向。

- 图一

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE3NjZjYzVlYTJhNmI3MDA3MmJkZTgwNWMxMmU5M2FfZm01VHg2VGNrV09oVUV2UEphQmVkRGdkbURGOW1WU05fVG9rZW46Ym94Y25tUXdrUVpBTEhTWTJqeUFNc1NXV2JmXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

- 图二

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=N2E3NzYzZjhiM2UxY2E2MDE1ZjQyZDEwYjgxNWE1N2FfRkNjRTE1bjNoanBDcUNQcmR0VE9ZbnhDQWwwTmdRcHRfVG9rZW46Ym94Y25GT3NjcTY5bUZ0bFF5c2NWN1M1Q1FoXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

我们既然学习了画布缩放变换“竞相翻转”，那么我们来创建一个如上图比较熟悉和方便的坐标系刻度轴。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmIzM2E2N2MzZGRmZjNhMTZlNDExMWEwMWQ4ZGM3YTJfZTFTZTYxN1NFcFVLY2p1cjJPRmJ4c0s5NlFybWZJcE1fVG9rZW46Ym94Y250VnRaVlhLdnd3RkEzblNyS1ZYcktoXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

首先我们的默认坐标系如何一步步变换为如上图坐标系呢？

- 1、坐标系默认View的左上角为圆心。
- 2、默认右下角为正方向，也就是圆心的X右边为正，Y轴圆心的下方为正方向。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NmZkYmQ1MDAzNTNlMTQ0MWExNmNiOTNjMzY3ZjYzNzRfNnhaREJJMkdrMExWZTZCR1VmdTVOVmdNRldaYTA3SFlfVG9rZW46Ym94Y254S2J6b3hDNkZBdGNqVDVoUkZZdFlkXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

- 3、X轴的右边为正方向满足条件。Y轴我们想向上为正。所以如何变换？当然，变换方法千千万，我们需要最优变换。接下来我们进行**canvas.scale(1f,-1f)**变换画布。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJkOWY2Nzg4OWE2ZmQ0MzY3ZDA0NDc2Yzk0NDBhNDlfaTVvNE1XY0pGaHRTQzlvSmdVVXZnVGt6OU5aZVZiUldfVG9rZW46Ym94Y25qZkxQbE9HNFhncEM4dDRRQktBeEVmXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

- 4、到这里，我们需要注意，此时Y轴方向上是正，向下是负，向下平移画布，即**canvas.translate(0f,-mHeight.toFloat())**变换之后如下:

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWVhODgwMWYwZWFhNmNkMTM1MTAxNTQwODU3NDU1OTlfS0hzMWlpT0lIUnhQdks4QlcxbWI2bm9OdGtQUFd6YVhfVG9rZW46Ym94Y25kMFNyNFdBR0pYZG84MDBtS21FZVdiXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

- 5、为了让坐标轴左边下边有距离间隙，我们继续利用平移变换进行画布变换，例如左边60像素，下边60像素，**canvas.translate(60f,60f)**，变换之后如下:

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIzYzBjOTViYzFjNmYwYTlhNjRjOGRkMTg5OTljYTdfZGt4cVBxOXpXcmR3Z3hLRHY5NjF3dEUwRlZxakkzU05fVG9rZW46Ym94Y25nRjNRNFVqTHA3ZFJjTkZneVYwYVBkXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

- 6、最后我们在次坐标系内绘制一个时间刻度轴如下所示

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NzAyMTIwZmEyN2Y2NGEwZWUzMjdmMDU2NGQ3NjA4MTdfNDM4ejdLRmNjYXNrQWtQN2ZXN3lKS0U0Q2J6SGR5aEhfVG9rZW46Ym94Y25uRVY0a0FSUnA4enI3ZzUzVlh4bWtlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

如上图有8个刻度线，分为了7等分，而且我们左右两边需要60像素的间距才好看，才有空间绘制其他刻度文字。所以代码如下：

细节部分：对于画笔宽度的精细计算如下paint.*strokeWidth*/2f，不明白的画笔设置粗一点自己手画计算或者看前面内容。当绘制刻度线时候，我们可以直接计算位置，也可以直接计算平移画布的距离，平移画布。本节课是画布变换的课程，我们尽可能用画布变换来搞定。

```Kotlin
val margin = 60f

private fun canvasScaleDrawLine(canvas: Canvas) {

    canvas.scale(1f,-1f)

    canvas.translate(0f,-mHeight.toFloat())

    canvas.translate(margin,margin)

    //1.绘制X轴

    canvas.drawLine(0f, 0f, mWidth.toFloat()-margin*2f, 0f, paint)

    val scaleWidth =( mWidth - margin*2 ) / 7f

    for (index in 0 until 8){

        canvas.drawLine(paint.strokeWidth/2f,0f,paint.strokeWidth/2f,10f,paint)

        canvas.translate(scaleWidth,0f)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZmNWZkMjcwMjVlNmNmZGRjOWM1NTI4NDk3NjcxZDJfOERVUHFRaTFUWFFjaGlsUjdneHk4Q2d5c0FOTEoxOTlfVG9rZW46Ym94Y25qdTlhdTVzT1NYZTNiUzFUVmoyR3FoXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

学到目前，我想大家对于下面这个刻度文字，应该来说是有想法的，很多人首次看到这样的自定义也许先来一堆代码，反复调试，耗时耗力。如果你和我一样几何计算不是很强的，先慢慢画一张草稿，仔细分析。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFmZDVmZTVmNWI0ODI5NzMxMWNlYjQ4ZjQwNzcxYzFfYWNoSTRxN2QwRUJQc2RqR1oyZ3cydGxpVklGVEZZc3pfVG9rZW46Ym94Y25PYUMyeWdvVWFOQnN5SFpBWTZlaTFHXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

如上图，我们可以看到文字在刻度中间，详细点来说文字中心在刻度中心，到这里我们也认识到问题关键就是计算**刻度起始点**到**文字起始**的距离。熟练自定义开发者当然不用计算起始点到文字起点的距离也可以轻松搞定，减少来逻辑转换过程。不用着急，容你想3分钟，画个草稿试一试，然后我们慢慢来。



**下图所示**，我们可以通过两个对比图，明确的计算出文字绘制起始的位置**mTextStartX = scaleWidth刻度宽度\*index + (scaleWidth刻度宽度 - 文字宽度) / 2f。**借助图像可以很快的解决简单的数学计算和规律，凭空想象浪费时间很没有必要。

```PHP
一、测量文字有两种方式



0、由于绘制刻度时候画布平移动到了X轴的末尾，所以我们需要将画布向左平移7个单位长度让坐标系圆点

回到左边。

canvas.translate(-8*scaleWidth,0f)



1、Paint的measureText(...)相关方法，返回文字的宽度。

public float measureText(String text)



2、Paint的getTextBounds可以通过设置bounds来返回文字区域的宽和高。

public void getTextBounds(String text, int start, int end, Rect bounds)
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YTZkNjdlNTk1NjFjZWVhNzlmYmU2MzE3YzM5ZTUwOWVfUXQ3UUI0b1ZIMThzUFAzZDF3d1BHRW1DYjRhMVJPT0tfVG9rZW46Ym94Y25rajk4cEV0TWpTcDdGQjB3N2NtanRoXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

公式和测量文字宽度的方法带入代码

```Kotlin
private val margin = 60f

private val arrayScale = arrayOf("Mon","Tue","Wed","Thu","Fri","Sat","Sunday")

private fun canvasScaleDrawLine(canvas: Canvas) {

    canvas.scale(1f,-1f)

    canvas.translate(0f,-mHeight.toFloat())

    canvas.translate(margin,margin)

    //1.绘制X轴

    canvas.drawLine(0f, 0f, mWidth.toFloat()-margin*2f, 0f, paint)

    val scaleWidth =( mWidth - margin*2 ) / 7f

    for (index in 0 until 8){

        canvas.drawLine(paint.strokeWidth/2f,0f,paint.strokeWidth/2f,10f,paint)

        canvas.translate(scaleWidth,0f)

    }

    canvas.translate(-8*scaleWidth,0f)

    for (index in arrayScale.indices){

       //文字的宽度

       val mTextWidth = paint.measureText(arrayScale[index])

       val mTextStartX = scaleWidth * index + (scaleWidth-mTextWidth)/2f

       canvas.drawText(arrayScale[index],mTextStartX,0f,paint)

    }

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NTczYzMyZDM2NzJlNDllMmZhMjEwZjljNGE2NTVkZWFfb2ZvQ0pNUnZDN2hxMkFSNllzU1hjOG5BemRNNVlFQ0VfVG9rZW46Ym94Y25XTU02bUh4dG8ydGFncWY3amFKNnNiXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

到这里很多人也注意到了，文字是竞相翻转的，这是为什么呢？大家有没有试过，默认坐标圆点在View的左上角情况下，文字的绘制是如何呢？如果没有尝试，大家可以猜想，很久之前作为初学者的我，自信的认为它就在坐标的右下方即如下图：

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y0ZDAyOTVlYTRhOGIyMWE4YTcxMmVkMTNiYzY5ZDZfZExjSm95VFkycmRpeVo5RXNKRU80aDhnY21WWG02RlRfVG9rZW46Ym94Y243MXhFQzZRczB0YWVRVGNIZHB0ZWdlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

其实真实的文字绘制在其右上角即X轴的正方向，Y轴坐标的负方向。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MmViYzIzMjJkNjkxMTllYjkyNjUxOTc1ZDE1MzQ3NjZfa3VNTXRvcG54U2JuYzM1cURaemdBeGZ1SW80MjRCYTBfVG9rZW46Ym94Y24xTGs0cGsxUEFQVkxDQW5aZHNiUjliXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

当前我们的坐标方向如下图，所以文字的绘制根据绘制方向和位置，并没有错

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWUxOWFiOTE4OWNhMmIyZmNhMmRkODU3MDhlMzFjZWVfQ0xzeXIxR081SWJidlZqeUg0ajF0bFZZckF2T1RaaDZfVG9rZW46Ym94Y242dEtMWHdZaDhwc1I5dTBTOXJGT3pLXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

这种情况下，我们可以通过坐标轴进行竞相翻转变换为常规的坐标系然后进行绘制文字，接下来看看代码和效果。

```Fortran
.....

canvas.translate(-8*scaleWidth,0f)

//竞相翻转

canvas.scale(1f,-1f)

for (index in arrayScale.indices){

   //文字的宽度

   val mTextWidth = paint.measureText(arrayScale[index])

   val mTextStartX = scaleWidth * index + (scaleWidth-mTextWidth)/2f

   canvas.drawText(arrayScale[index],mTextStartX,0f,paint)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I1YWNhOThkYTYzZjQxN2Y2MTE0YmY1NWM1MjVlZTFfWFlHRUg0S25FOEp2ZEZIWG83eFJXRml1U3NEUWJnUU1fVG9rZW46Ym94Y240T1B4dkxtYU9KVlBaeFNvdHYwZWtoXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

上图可以看到，文字方向没啥问题了，只需要将文字向下平移一定的高度即可，至少大于文字高度即可，我们不妨设置为文字高度的1.3倍。

```Apache
//获取当前文字的高度，当文字大小即textSize设置完成，文字高度基本固定，

//所以我们测量第一个字符串高度即可。

val bounds = Rect()

paint.getTextBounds(arrayScale[0],0,arrayScale[0].length,bounds)

canvas.translate(0f,bounds.height().toFloat()*1.3f)
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBhZmUzNzg3ZGY4OTk4YjQ0NTA1NGRiMzM0NDNhOGZfdDJpdGVyQmt3eGdGbUxwZmExbWVPdG1VRzRsemtKS1lfVG9rZW46Ym94Y250TkFQVnZSVFJ6R21YaHlZdVlxU2JnXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

到这里我们就完成了这个刻度轴的绘制，当然了当前不管是配色还是粗细都比较丑，但是我希望大家跟我一样，一步步分析下来，本节课程内容后面频频出现，也在你平日的开发者不可缺少，如果你跟着完整的敲完并认真的绘图理解了这节课，我相信你的自定义大门已经打开。



在上述过程中，我们首先绘制了刻度轴和刻度，当我们绘制文字时候，我们做了一个画布的平移变换，即**canvas.translate(-8\*scaleWidth,0f)，**目前由于我们的画布变换比较简单，如果遇到了复杂的画布变换，当我们需要回到某一画布所在`**位置**`和`**状态**`时候，难道我们每次还需要做逆运算？当然不是了，为了开发者的方便，Google为画布状态的`**canvas.save保存**`和`**canvas.restore()恢复**`**，**提供了私有栈操作。也就是接下来这节课的重点之重，画布状态的储存与恢复。

## 画布状态

相信大家都用过git 命令行吧，当我们在本地修改了内容，提交时候一般需要git pull一下，保证本地和仓库代码一致，在pull之前一般都会git stash吧，接着git pull，然后通过git stash apply @...对应的记录去恢复我们修改内容，然后去进行提交......不知道我说的明白不。

**画布状态保存**也是如此，当我们绘制过程中下一步有比较大的差异，或者逻辑和绘制差距较大，与当前绘制结果关系不大【耦合度低，毫不相关，例如画了一个耳朵，下一个是手，手和耳朵毫不相关，可以单独绘制】的时候，想保存当前状态，我们可以通过**canvas.save()**将当前的矩阵【这里理解为当前绘制内容包括画布当前的坐标系】保存在堆栈里面，假如当前画了一个眼睛。然后我们继续绘制其他内容。当然我们如果这时候我们绘制完了另一个重要的耳朵部分，我们也可以继续进行**canvas.save()**将当前耳朵部分矩阵继续保存在堆栈里面....当我们下次需要绘制眼睛旁边的眼泪时候。我们需要将画布坐标系恢复到眼睛旁边。那这时候我们就需要将堆栈里面的其他状态进行弹出，恢复到绘制眼睛时候的状态。

就上面例子我们画图理解吧。首先我们来统计一下，上面操作步骤。

```CSS
1、坐标系移动到了眼睛位置，绘制了一个黑色的眼睛。然后通过canvas.save()保存当前矩阵

2、坐标系移动到了耳朵位置，绘制了一个红色的耳朵。然后通过canvas.save()保存了当前的矩阵

3、我们需要绘制眼睛部分的眉毛。我们需要回到绘制眼睛的状态。那么我们需要canvas.restore()

   回到上一个状态
package com.example.draw_android.section05_canvas.d_save_restore



import android.content.Context

import android.graphics.Canvas

import android.graphics.Color

import android.graphics.Paint

import android.util.AttributeSet

import android.view.View



/**

 * Created by wangfei44 on 2022/4/21.

 */

class CanvasStateView constructor(context: Context, attributeSet: AttributeSet) :

    View(context, attributeSet) {

    private var mWidth = 0

    private var mHeight = 0

    val paint = Paint().apply {

        color = Color.BLACK

        style = Paint.Style.STROKE

        isAntiAlias = true

        textSize = 24f

    }



    private val paintEye = Paint().apply {

        color = Color.BLACK

        strokeWidth = 5f

        style = Paint.Style.FILL

        isAntiAlias = true

    }

    private val paintEar = Paint().apply {

        color = Color.RED

        strokeWidth = 5f

        style = Paint.Style.FILL

        isAntiAlias = true

    }



    override fun onDraw(canvas: Canvas) {

        super.onDraw(canvas)

        canvas.save()

        //1.绘制眼睛

        drawEye(canvas)

    }





    private fun drawEye(canvas: Canvas) {

        //平移画布到绘制眼睛的位置。我这里随意移动到400，400位置。

        canvas.translate(400f, 400f)

        canvas.drawText("眼睛",30f,30f,paint)

        canvas.drawCircle(0f, 0f, 20f, paintEye)

        //1.接下来绘制耳朵，所以保存好当前眼睛绘制场景的矩阵，保证后期可以通过restore恢复到这里

        canvas.save()

    }

    

  }
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YzMwNTUxMmEzYmIzMWEyNTU1NzIxZTM0NDlkNGUzMjVfZVNjMDlSTVB5bkpoWTgyNFRYRTZYZ0Y1UzVYWjlreHJfVG9rZW46Ym94Y255ZnlQclFUMnRnQzZQS0pqMDdOaDBlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

如上图，坐标系移动到了眼睛位置，绘制了一个黑色的眼睛和文字。然后通过canvas.save()保存当前矩阵到**STACK堆栈**内存中，这里的矩阵可以理解为图二的**绘制内容**和**坐标系**。

接下来，我们继续平移坐标系在平移之后的位置绘制红色圆圈代表耳朵然后再次保存当前矩阵如下图。可以看到，当第二次保存之后堆栈里面有两个画布矩阵储存，且最新的矩阵状态在最上层。

```Kotlin
private fun drawEar(canvas: Canvas) {

    canvas.translate(150f, 0f)

    canvas.drawText("耳朵",30f,30f,paint)

    canvas.drawCircle(0f, 0f, 20f, paintEar)

    //2.接下来其他部分，所以保存好当前耳朵绘制场景的矩阵

    canvas.save()

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjNkODI1OWU1NTQyNzQ5MjhlZDRjMzkwOGJlOWY1ZDJfdThCbzVMZVlVRTVHQjJBTWR6cUhtdUNnQzVpMk5sTllfVG9rZW46Ym94Y25hZ1huUUFsdHB3SGFINk5tanp1VW9jXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

接下来，我们要绘制眼眉毛，但是如果按照当前耳朵的坐标系可能绘制比较费劲，而我们依据眼睛绘制眉毛应该来说是比较方便快捷的。所以我们如何回到眼睛的参考坐标系矩阵状态呢？我们上面也提到了**canvas.restore()**。我们通过图来看看**canvas.restore()时候**STACK堆栈发生了什么**。**上图中我们可以看到，堆栈里面最顶层的矩阵和目前我们屏幕上的矩阵是一样的。所以通过canvas.restore()此时，屏幕的画布矩阵还是最新的矩阵，也就说没有变化。我们通过下面代码测试前后的效果：

```Kotlin
private fun drawEyebrow(canvas: Canvas) {

    canvas.drawLine(-30f,-30f,20f,-30f,paintEar)

}

//或者



private fun drawEyebrow(canvas: Canvas) {

    //通过restore 返回到堆栈STACK最顶层的矩阵状态

    canvas.restore()

    canvas.drawLine(-30f,-30f,20f,-30f,paintEar)

}
```



![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NmRiNTIyOTM2N2Q4OGM3N2M0ZDdlYTQ0NzQ1YjY1NTFfOFk0M1MyYlY0QzZ2TXJWNVRFcFhhTDNiVU9FNkYwNVBfVG9rZW46Ym94Y25aMUxiMDROc29vN0NwaGZzTFJnZjRmXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

通过上图，我们可以看到，因为canvas.restore()之前和第一次canvas.restore()之后所在的画布矩阵都是最新的所以，绘制眼眉毛在同样的位置。当前只剩下一个矩阵状态的堆栈基础上，我们继续canvas.restore()，也就是我们矩阵状态回到了第一次保存的状态。我们这时候再次绘制眼眉毛看看效果。

```Kotlin
private fun drawEyebrow(canvas: Canvas) {

    //3.我们需要回到眼睛绘制状态下的矩阵，可以轻松简单的绘制眉毛，因为有眼睛的参考。

    //通过restore 返回到堆栈STACK最顶层的矩阵状态

    canvas.restore()

    //回到了第一次保存的矩阵状态

    canvas.restore()

    //绘制眼眉毛

    canvas.drawLine(-30f,-30f,20f,-30f,paintEar)

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRiMjlhYTgxNTFiNjRhZDBiNjIwYWFlMmUxYTEwYTBfemFzdWwyckFxTTBMSUowSkhxaFQyZWlqOHFNU1UzQ1pfVG9rZW46Ym94Y244WVIxbnNySE0wTUViUGw2ZGFhMlljXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

根据上面的案例图解，我们应该差不多理解了画布状态的储存和恢复。如果你不理解，那就再多看几遍，或者自己通过小练习多多磨练。当然了，我们后面的课程会涉及到各种状态储存和恢复，可以说不理解画布的变换，寸步难行。

### **华为表盘完善**

下图1和图2分别是华为时钟表盘和我们这节课绘制的比较简陋的表盘。我们可以看到绘制的文字刻度华为刻度文字是竖着的，而我们的是有角度的。接下来，利用今天所学来解决这个问题。

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdiOWMyZDRkMzQ1ZGM5ZDNkZmJhNDM1MTI4NzY1NzBfSFBjRlF2d2NkV0Zia2xDdE8yQVc0QVhIemJJSjJWUDRfVG9rZW46Ym94Y25USkh1Vzhpd2JwU3A3cmF5VGZGdk05XzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=NGYxNTc4OTNkZjAzNDNlMzAxNTEyZjVlMGI3MjJkNTlfc2lPNkdqR1p4WU5QNUNhcWZ6UzFET01sVVI1QklsNm1fVG9rZW46Ym94Y25lOUczQmFidFNmMjFZR3FSR1BVcHVlXzE3MDE5MjUwMjI6MTcwMTkyODYyMl9WNA)

首先我们来看看，为啥文字绘制会有角度，我相信前面文字绘制方向应该没有忘记，我们绘制整个过程都是通过旋转进行变换，所以文字绘制会有角度。我们将**文字绘制坐标系**平移到**文字绘制附近**，然后进行旋转变换呢？我们是否可以**单独**的操作**每一个文字**刻度的**位置**呢。当然可以。

```Kotlin
private val arrayNumber  = arrayOf(12,1,2,3,4,5,6,7,8,9,10,11)

private fun drawScaleText(canvas: Canvas) {

    for (index in 0 until 12) {

        val R = width / 3f

        val startX = 0f

        val startY = -R + 30f

        val endX = 0f

        val endY = -R + 30f + 35f

        canvas.drawLine(startX, startY, endX, endY, hourPaint)

        canvas.rotate(30f)

    }



    for (index in arrayNumber.indices) {

        val R = width / 3f

        val startX = 0f

        val endY = -R + 30f + 35f

        //刻度绘制文字

        val text = arrayNumber[index].toString()



        val rect = Rect()

        textPaint.getTextBounds(text, 0, text.length, rect)

        //进行状态储存

        canvas.save()

        //将坐标系位置移动到绘制文字的底部。

        canvas.translate(startX - rect.width()/2f,endY + 20f+rect.height())

        //因为整体会做旋转，为了让坐标系摆正，我们好一个个调整文字间距，那么需要逆时针进行旋转。

        canvas.rotate(-30f*(index))

        //画个X,Y参考坐标系。

        canvas.drawLine(0f,0f,100f,0f,textPaint)

        canvas.drawLine(0f,0f,0f,100f,textPaint)

        //绘制文字。

        canvas.drawText(

            arrayNumber[index].toString(),

            0f,//手动画一下，startX为12点刻度减去文字的一半就是文字起始的X

            0f,//文字在刻度下面，至少文字高度的地方，且给了20像素的空间

            textPaint

        )

        canvas.restore()

        canvas.rotate(30f)

    }

    

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzc4NzQ2MTc5YmIwYjA0Nzg4ZjNhOGNlZjY2YTg1NzFfaVdVQUw2RjMyd2dJczRjbjdCa2dtQjhqMXVVakt0ZnhfVG9rZW46Ym94Y25ENG4xaVEyMURoRFFTUkJLMG5vTlpmXzE3MDE5MjUwMjM6MTcwMTkyODYyM19WNA)

根据上图坐标系，相信大家可以快速简单的对于每一个刻度文字进行调整了吧。下面我大概用了2分钟不到调整了一下每个文字的位置。我们可以感受到，canvas状态的储存和恢复，让我们在绘制中如鱼得水，不影响大局，也可操作局部。

```Kotlin
private fun drawScaleText(canvas: Canvas) {

    for (index in 0 until 12) {

        val R = width / 3f

        val startX = 0f

        val startY = -R + 30f

        val endX = 0f

        val endY = -R + 30f + 35f

        canvas.drawLine(startX, startY, endX, endY, hourPaint)

        canvas.rotate(30f)

    }



    for (index in arrayNumber.indices) {

        val R = width / 3f

        val startX = 0f

        val endY = -R + 30f + 35f

        //刻度绘制文字

        val text = arrayNumber[index].toString()



        val rect = Rect()

        textPaint.getTextBounds(text, 0, text.length, rect)

        //进行状态储存

        canvas.save()

        //将坐标系位置移动到绘制文字的底部。

        canvas.translate(startX - rect.width() / 2f, endY + 20f + rect.height())

        //因为整体会做旋转，为了让坐标系摆正，我们好一个个调整文字间距，那么需要逆时针进行旋转。

        canvas.rotate(-30f * (index))

        //画个X,Y参考坐标系。

        canvas.drawLine(0f, 0f, 100f, 0f, textPaint)

        canvas.drawLine(0f, 0f, 0f, 100f, textPaint)

        when (index) {

            3 -> {

                canvas.translate(0f, rect.height() / 2f)

            }

            4, 5, 6 -> {

                canvas.translate(-rect.width().toFloat(), rect.height().toFloat())

            }

            7, 8 -> {

                canvas.translate(-rect.width().toFloat(), rect.height().toFloat() / 2f)

            }

            9 -> {

                canvas.translate(-rect.width().toFloat(), 0f)

            }

            10 -> {

                canvas.translate(-rect.width().toFloat() / 2f, -rect.height().toFloat() / 2f)

            }

        }

        //绘制文字。

        canvas.drawText(

            arrayNumber[index].toString(),

            0f,//手动画一下，startX为12点刻度减去文字的一半就是文字起始的X

            0f,//文字在刻度下面，至少文字高度的地方，且给了20像素的空间

            textPaint

        )

        canvas.restore()

        canvas.rotate(30f)

    }



}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ0MDcyNWJjMzY3NTdlMGMyMTE1NzVjNmFmZjFiMTdfZ1M1d0Exc3h3WFVuTnJFbkxqbk4zcUVVNGJ5NURrdm9fVG9rZW46Ym94Y25ud3ZWRlJ2ODk0YXpUcWE1cTl6dW45XzE3MDE5MjUwMjM6MTcwMTkyODYyM19WNA)

字体不够黑。这时候需要回忆一下之前的知识了，我们画笔设置个strokeWidth，画笔粗细要起作用，我们需要style设置那两个才会起作用呢？如果忘记了可以回顾之前的知识。

```Nginx
//我们简单的设置strokeWidth 和 style 让画笔粗细起作用，达到粗细效果。

private val textPaint = Paint().apply {

    color = Color.BLACK

    textSize = 36f

    strokeWidth = 2f

    style = Paint.Style.FILL_AND_STROKE

    isAntiAlias = true

}
```

![img](https://qz8m0dtxv0.feishu.cn/space/api/box/stream/download/asynccode/?code=YTc0MDUxYjVjY2VhMGYwM2I5NTFkMjQ0ZmFmZDRhYjFfczlrZVBUVm9OWWR6dGRETWlrNDhVeGR6cms1VG5JUVVfVG9rZW46Ym94Y255TEpYZTUzd29lbDByWE95RnRnRVdoXzE3MDE5MjUwMjM6MTcwMTkyODYyM19WNA)

到这里我们也感受到了，画布状态的储存和恢复在我们绘制中有着极其重要的作用。没有了画布状态的储存很多操作都需要大量的精力进行复杂计算。所以这节课画布状态的储存和恢复必须掌握。除了save方法，还有saveLayer等方法，后面会在相关绘制章节单独拧出来学习。

## 总结

到这里，可能看着没有华为表盘的好看，好看的背景是UI设计师的图片，没必要纠结，后面这些都会讲到，当然了涉及到一些没学到的贴图API像**canvas.drawBitmap**等。指针动起来也就那回事，这个涉及到后面简单的动画，和画布的刷新以及如何通过系统广播来进行刷新分针转动，如何正确的刷新秒针的转动。很多小伙伴应该发现setSkew(float kx,float ky)并没有讲解，这个任务交给大家，当然了不要着急，后面涉及到图片的编辑我们可以详细学习，由于这个小结内容过多，下节课继续学习画布其他相关API。还是那句话，如果你不是天才，我希望你和我一样动手动脑，不落实到动手以及反复的练习，是无法达到胸有成竹，独立绘制开发的水平的。